import java.io.File
import java.io.FileWriter
import java.io.BufferedWriter
import scala.util.matching.Regex
import scala.util.matching.Regex.Match

trait ColorPropertiesGenerator{
	def generateColorPropertiesFunc(){

		val file = new File("src/main/scala/me/winsh/scalaedit/gui/editor/SyntaxHighlightingProperties.scala")

		//if(!file.exists)
			generateColorProperties(file)
	
		
	}

	def stringToCamelCase(text:String) = {
    val split = text.split("_").toList
    
    (split.head::(split.tail.map(_.capitalize))).mkString("")

	}

	private def generateColorProperties(file:File){

		val writer = new BufferedWriter(new FileWriter(file))


		//Write beginning
		
		writer.write("""

/*
ScalaEdit - A text editor for Scala programmers
Copyright (C) 2011  Kjell Winblad (kjellwinblad@gmail.com)

This program is free software: you can redistribute it and/or modify
it under the terms of the GNU General Public License as published by
the Free Software Foundation, either version 3 of the License, or
(at your option) any later version.
*/

/*
OBS:This file is generated by project/build/ColorPropertiesGenerator.scala
*/
		
package me.winsh.scalaedit.gui

import me.winsh.scalaedit.api._
import java.io.File
import me.winsh.scalaedit.gui._
import java.awt.Color
import org.fife.ui.rtextarea._
import org.fife.ui.rsyntaxtextarea._
import java.awt.Font

class SyntaxHighlightingProperties
  extends PropertiesFile(new File(Utils.propertiesDir, "syntax_highlighting.properties"),
    "Editor Color Properties") {

	private val scheme = {
		val textArea = new RSyntaxTextArea(20, 60);
		textArea.getSyntaxScheme();
	}
""")

    val tokens =List(
		 "comment_documentation",
		 "comment_eol",
		 "comment_multiline",
		 "data_type",
		 "error_char",
		 "error_identifier",
		 "error_number_format",
		 "error_string_double",
		 "function",
		 "identifier",
		 "literal_backquote",
		 "literal_boolean",
		 "literal_char",
		 "literal_number_decimal_int",
		 "literal_number_float",
		 "literal_number_hexadecimal",
		 "literal_string_double_quote",
		 "markup_tag_attribute",
		 "markup_tag_delimiter",
		 "markup_tag_name",
		 "operator",
		 "preprocessor",
		 "reserved_word",
		 "separator",
		 "variable",
		 "whitespace")

		 //Write properties for all tokens

			for(token <- tokens){
				writer.write("""
				val %sBackground = new ColorProperty("%s_background", scheme.styles(Token.%s).background)		
			""".format(stringToCamelCase(token),token,token.toUpperCase))

				writer.write("""
				val %sForeground = new ColorProperty("%s_foreground", scheme.styles(Token.%s).foreground)		
			""".format(stringToCamelCase(token),token,token.toUpperCase))

			
				writer.write("""
				val %sUnderline = new BooleanProperty("%s_underline", scheme.styles(Token.%s).underline)	
			""".format(stringToCamelCase(token),token,token.toUpperCase))
		 	
				writer.write("""
				val %sBold = new BooleanProperty("%s_bold", {
					val font = scheme.styles(Token.%s).font
					if(font==null) false else font.isBold
				})	
			""".format(stringToCamelCase(token),token,token.toUpperCase))

				writer.write("""
				val %sItalic = new BooleanProperty("%s_italic", {
					val font = scheme.styles(Token.%s).font
					if(font==null) false else font.isItalic
				})	
			""".format(stringToCamelCase(token),token,token.toUpperCase))
				//scheme.styles[Token.RESERVED_WORD].background = Color.pink;
      	//scheme.styles[Token.DATA_TYPE].foreground = Color.blue;
      	//scheme.styles[Token.LITERAL_STRING_DOUBLE_QUOTE].underline = true;
		 }

		 writer.write("""
				def schemeFromProps(font:Font) ={
					val  textArea = new RSyntaxTextArea(20, 60);

					val scheme = textArea.getSyntaxScheme();
				""")
			for(token <- tokens){
					writer.write("""
				scheme.styles(Token.%s).background = %sBackground.get
			""".format(token.toUpperCase, stringToCamelCase(token)))

					writer.write("""
				scheme.styles(Token.%s).foreground = %sForeground.get
			""".format(token.toUpperCase, stringToCamelCase(token)))

					writer.write("""
				scheme.styles(Token.%s).underline = %sUnderline.get
			""".format(token.toUpperCase, stringToCamelCase(token)))

					writer.write("""
				scheme.styles(Token.%s).font = new Font(font.getName(),{
					((if(%sBold.get) List(Font.BOLD) else Nil):::
					(if(%sItalic.get) List(Font.ITALIC) else Nil)).foldLeft(0)(_ | _)
				},font.getSize)
			""".format(token.toUpperCase, stringToCamelCase(token), stringToCamelCase(token), stringToCamelCase(token)))
			
			}
			writer.write("""
					scheme
				}

    }
			""")

		writer.flush()
		writer.close()
	}
}